* Emacs Configuration

My emacs configuration is a literate Emacs Lisp program, using
=org-mode= [[http://orgmode.org/worg/org-contrib/babel/intro.html][Babel]]. I got the idea from [[https://www.youtube.com/watch?v=SzA2YODtgK4][this talk by Harry Schwartz]], see
about 20 minutes in.

** Personal information

#+BEGIN_SRC emacs-lisp
  (setq user-full-name    "Michael Walker"
        user-mail-address "mike@barrucadu.co.uk")
#+END_SRC

** Configuration

Firstly, let's set up some stuff relating to my emacs configuration
itself.

I don't really use the emacs =customize= system, preferring to keep
things in this file. I use a separate, non-version-controlled, file
for its settings:

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")

  (when (file-exists-p custom-file)
    (load custom-file))
#+END_SRC

** Package management

I use [[https://github.com/jwiegley/use-package][=use-package=]] to manage most of my configuration, which includes
fetching packages. It's incredibly convenient, and results in very
readable config. There's a great blog post by Sebastian Wiesner [[http://www.lunaryorn.com/2015/01/06/my-emacs-configuration-with-use-package.html][on his
use of it]].

#+BEGIN_SRC emacs-lisp
  (package-initialize)

  (require 'package)
  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))

  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)
#+END_SRC

Some things don't come in packages, alas.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/lisp/")
#+END_SRC

** User interface
*** Get rid of the tool bar, menu bar, and scroll bar.

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (when window-system
    (scroll-bar-mode -1))
#+END_SRC

*** No blinking and beeping

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'blink-cursor-mode)
    (blink-cursor-mode -1))
  (setq ring-bell-function 'ignore)
#+END_SRC

*** No splash screen on startup

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
#+END_SRC

*** Gruvbox colour theme

This is the first use of =use-package= in the configuration. This
snippet requires the =color-theme= and =gruvbox-theme= packages to be
installed (and will fetch them if not, due to the =(setq
use-package-always-ensure t)= in the =use-package= configuration), and
loads the gruvbox theme at start-up.

#+BEGIN_SRC emacs-lisp
  (use-package color-theme)
  (use-package gruvbox-theme
    :init (load-theme 'gruvbox 'no-confirm))
#+END_SRC

*** Highlights
**** Cursor on window scroll

The =:diminish= here uses [[https://github.com/myrjola/diminish.el][=diminish=]] to remove [[https://github.com/Malabarba/beacon][=beacon-mode=]] from the
mode-line, as I'm enabling it globally.

#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :init (beacon-mode 1)
    :diminish beacon-mode)
#+END_SRC

**** The current line

Changes the background of the current line when in a windowing system
(alas, would be nice if it also worked in the terminal).

#+BEGIN_SRC emacs-lisp
  (when window-system
    (global-hl-line-mode 1))
#+END_SRC

**** Matching parentheses

By default, =show-paren-mode= has a slight delay. I don't like that,
so I set =show-paren-delay= to turn it off.

#+BEGIN_SRC emacs-lisp
  (setq show-paren-delay 0)
  (show-paren-mode 1)
#+END_SRC

The [[https://github.com/Fanael/rainbow-delimiters][=rainbow-delimiters=]] package uses different colours for nested
parentheses, making them easier to visually track.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :init (progn (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
                 (add-hook 'conf-mode-hook 'rainbow-delimiters-mode)))
#+END_SRC

** Keybindings

I use a simple prefix scheme for all my custom keybindings, pretty
much everything has the form =C-c <key> <binding>=, where =<key>= is
some operation-specific key. I use [[https://github.com/justbur/emacs-which-key][=which-key=]] to provide hints based
on this scheme.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :init (which-key-mode)
    :config
    (setq which-key-idle-delay 0.3
          which-key-sort-order 'which-key-prefix-then-key-order)

    (which-key-declare-prefixes
      ;; Global prefixes and minor modes
      "C-c @"   "outline"
      "C-c !"   "flycheck"
      ;; Prefixes for my personal bindings
      "C-c b"   "buffers"
      "C-c c"   "comments"
      "C-c f"   "files"
      "C-c g"   "git"
      "C-c l"   "language/spelling"
      "C-c m"   "major-mode"
      "C-c o"   "cursors"
      "C-c p"   "projectile"
      "C-c s"   "search"
      "C-c t"   "toggle"
      "C-c x"   "text")

    ;; Prefixes for major modes
    (which-key-declare-prefixes-for-mode 'markdown-mode
      "C-c TAB" "markdown/images"
      "C-c C-a" "markdown/links"
      "C-c C-c" "markdown/process"
      "C-c C-s" "markdown/style"
      "C-c C-t" "markdown/header"
      "C-c C-x" "markdown/structure")

    (which-key-declare-prefixes-for-mode 'haskell-mode
      "C-c m"   "haskell/personal"
      "C-c m i" "haskell/imports")

    (which-key-declare-prefixes-for-mode 'go-mode
      "C-c m"   "go/personal")
    :diminish which-key-mode)
#+END_SRC

** Org

I use =org-mode= as my default major-mode, not just for org files.

#+BEGIN_SRC emacs-lisp
  (setq initial-major-mode 'org-mode)
  (add-hook 'org-mode-hook 'org-indent-mode)
  (add-hook 'org-mode-hook 'visual-line-mode)
  (setq org-src-tab-acts-natively t
        org-src-fontify-natively  t)
#+END_SRC

I'm also experimenting with org for persistent personal organisation,
rather than just one-off todo lists:

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files '("~/s/org/inbox.org"
                           "~/s/org/todo.org"
                           "~/s/org/someday.org"))

  (bind-key "<f6>"  'org-capture)
  (bind-key "<f7>"  'org-refile)

  (setq org-capture-templates '(("t" "Todo [inbox]"   entry (file "~/s/org/inbox.org")   "* TODO %i%?")
                                ("T" "Todo [someday]" entry (file "~/s/org/someday.org") "* TODO %i%?")))

  (setq org-refile-targets '((nil :maxlevel . 9)
                             (org-agenda-files :maxlevel . 9)))

  (setq org-outline-path-complete-in-steps nil)

  (setq org-refile-use-outline-path t)

  (setq org-todo-keywords '((sequence "TODO(t)" "IN-PROGRESS(p)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)" "REFILED(r)")))
#+END_SRC

** Flycheck and Flyspell

The [[http://www.flycheck.org/][=flycheck=]] package is a fantastically useful piece of work, it
performs continuous mode-specific correctness-checking (eg: compiler
errors for programming). The [[https://www.emacswiki.org/emacs/FlySpell][=flyspell=]] package is similar for
text. Both are great. You're doing it wrong if you're not using both.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :init (global-flycheck-mode))
#+END_SRC

Here we also see an example of binding keys with =use-package=. The
=C-c t= prefix is for text commands, and so is used here for flyspell.

#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :bind (("C-c t s" . flyspell-mode)
           ("C-c l b" . flyspell-buffer))
    :init (progn (add-hook 'text-mode-hook  'flyspell-mode)
                 (add-hook 'prog-mode-hook  'flyspell-prog-mode)
                 (add-hook 'org-mode-hook   'flyspell-mode)
                 (add-hook 'LaTeX-mode-hook 'flyspell-mode))
    :config (progn (setq flyspell-use-meta-tab nil
                         flyspell-issue-welcome-flag nil
                         flyspell-issue-message-flag nil)
                   (define-key flyspell-mode-map "\M-\t" nil)
                   (define-key flyspell-mouse-map [down-mouse-2] nil)
                   (define-key flyspell-mouse-map [mouse-2] nil))
    :diminish flyspell-mode)
#+END_SRC

I use =aspell= for =flyspell-mode=:

#+BEGIN_SRC emacs-lisp
  (use-package ispell
    :defer t
    :config (setq ispell-program-name (executable-find "aspell")
                  ispell-dictionary "en_GB"
                  ispell-silently-savep t
                  ispell-choices-win-default-height 5))
#+END_SRC

=proselint= is a Python program for linting prose, as the name may
suggest. It's not a spelling or grammar checker, instead it focuses on
logic and style.

#+BEGIN_SRC emacs-lisp
  (flycheck-define-checker proselint
    "A linter for prose."
    :command ("proselint" source-inplace)
    :error-patterns
    ((warning line-start (file-name) ":" line ":" column ": "
              (id (one-or-more (not (any " "))))
              (message (one-or-more not-newline)
                       (zero-or-more "\n" (any " ") (one-or-more not-newline)))
              line-end))
    :modes (text-mode markdown-mode latex-mode rst-mode))

  (add-to-list 'flycheck-checkers 'proselint t)
#+END_SRC

=vale= is another prose style linter, but rather more opinionated than
=proselint=.

#+BEGIN_SRC emacs-lisp
  (customize-set-variable 'flycheck-vale-modes '(text-mode markdown-mode latex-mode rst-mode))
  (require 'flycheck-vale)
  (add-to-list 'flycheck-checkers 'vale t)
#+END_SRC

Finally, we want both =vale= and =proselint= to work nicely together
and in LaTeX documents.

#+BEGIN_SRC emacs-lisp
  (flycheck-add-next-checker 'tex-chktex  'proselint t)
  (flycheck-add-next-checker 'tex-lacheck 'proselint t)
  (flycheck-add-next-checker 'proselint   'vale      t)
#+END_SRC

** Accounting

I use [[http://plaintextaccounting.org/][plaintext accounting]], and in particular [[http://hledger.org/][hledger]], to manage my
finances. It's really nice and I highly recommend it.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-ledger)
  (use-package ledger-mode
    :mode "\\.ledger\\'\\|\\.journal\\'"
    :config
    (setq ledger-binary-path (executable-find "hledger")
          ledger-mode-should-check-version nil
          ledger-init-file-name " "
          ledger-post-amount-alignment-column 80
          ledger-highlight-xact-under-point nil)
    (add-hook 'ledger-mode-hook (lambda () (setq tab-width 1)))
    (add-hook 'ledger-mode-hook 'orgstruct-mode))
#+END_SRC

** Programming

My programming set-up is quite simple compared to all the
functionality that emacs can offer: flycheck and syntax highlighting
provide basically everything I want.

Emacs' default "electric" indenting can be a bit overzealous
(particularly for Haskell, it seems), so turn that off:

#+BEGIN_SRC emacs-lisp
  (electric-indent-mode 0)
#+END_SRC

I also like to be able to comment things easily.  The =bind-key=
package being used here is part of =use-package=. Because I can never
remember, "dwim" is an acronym for "do what I mean".

#+BEGIN_SRC emacs-lisp
  (require 'bind-key)
  (bind-key "C-c c d" 'comment-dwim)
  (bind-key "C-c c l" 'comment-line)
  (bind-key "C-c c r" 'comment-region)
#+END_SRC

Ok, that's it for preliminaries.

*** Elixir

#+BEGIN_SRC emacs-lisp
  (use-package elixir-mode
    :mode "\\.ex\\'\\|\\.exs\\'")
#+END_SRC

*** Forth

#+BEGIN_SRC emacs-lisp
  (use-package forth-mode
    :mode "\\.fs\\'")
#+END_SRC
*** Haskell

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :mode "\\.hs\\'"
    :bind (:map haskell-mode-map
                ("M-."       . haskell-mode-jump-to-def-or-tag)
                ("C-c m i j" . haskell-navigate-imports)
                ("C-c m i s" . haskell-sort-imports)
                ("C-c m i a" . haskell-align-imports)))

  (use-package haskell-compile
    :ensure haskell-mode
    :bind (:map haskell-mode-map
                ("C-c m c" . haskell-compile)
                ("<f5>"    . haskell-compile))
    :config (setq haskell-compile-cabal-build-command "stack build"))

  (use-package haskell-cabal-mode
    :mode "\\.cabal\\'"
    :ensure haskell-mode)
#+END_SRC

*** JSON

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :mode "\\.json\\'"
    :config (add-hook 'json-mode-hook (lambda () (setq-local js-indent-level 4))))

  (use-package json-reformat
    :bind (("C-c x j" . json-reformat-region)))
#+END_SRC

*** Python

#+BEGIN_SRC emacs-lisp
  (use-package python
    :mode ("``.py``'" . python-mode))
#+END_SRC

*** Go

This runs =gofmt= on save, which is really convenient.

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :mode "\\.go\\'"
    :commands (godoc gofmt gofmt-before-save)
    :bind (:map go-mode-map
                ("C-c m f" . gofmt)
                ("C-c m i" . go-goto-imports)
                ("C-c m r" . go-remove-unused-imports))
    :init (progn (defun barrucadu/maybe-gofmt-before-save ()
                   (when (eq major-mode 'go-mode)
                     (gofmt-before-save)))
                 (add-hook 'before-save-hook 'barrucadu/maybe-gofmt-before-save)))
#+END_SRC

*** Groovy

#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :mode "\\.groovy\\'")
#+END_SRC

*** Lua

#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :mode "\\.lua\\'")
#+END_SRC

*** Nix

#+BEGIN_SRC emacs-lisp
  (use-package nix-mode
    :mode "\\.nix\\'")
#+END_SRC

*** Puppet

#+BEGIN_SRC emacs-lisp
  (use-package puppet-mode
    :mode "\\.pp\\'")
#+END_SRC
*** Rust

Like with Go, this formats code on save.

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :mode "\\.rs\\'"
    :config  (setq rust-format-on-save t))
  (use-package flycheck-rust
    :init (add-hook 'flycheck-mode-hook 'flycheck-rust-setup))
#+END_SRC

*** Ruby

#+BEGIN_SRC emacs-lisp
(setq ruby-insert-encoding-magic-comment nil)
#+END_SRC

*** Scala

#+BEGIN_SRC emacs-lisp
  (use-package scala-mode
    :mode "\\.scala\\'")
#+END_SRC

*** Shell

#+BEGIN_SRC emacs-lisp
  (use-package sh-script
    :mode ("\\.zsh\\'" . sh-mode)
    :config (setq sh-indentation 2
                  sh-basic-offset 2))
#+END_SRC

*** Terraform

#+BEGIN_SRC emacs-lisp
  (use-package terraform-mode
    :mode ("\\.tf``'" . terraform-mode))
#+END_SRC

*** TOML

#+BEGIN_SRC emacs-lisp
  (use-package toml-mode
    :mode ("\\.toml``'" . toml-mode))
#+END_SRC

*** TypeScript

#+BEGIN_SRC emacs-lisp
  (use-package typescript-mode
    :mode ("\\.ts\\'" "\\.tsx\\'"))
#+END_SRC

*** YAML

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode "\\.yaml\\'"
    :config (add-hook 'yaml-mode-hook (lambda () (run-hooks 'prog-mode-hook))))
#+END_SRC

** Writing

I have a couple of modes available for distraction-free writing:

#+BEGIN_SRC emacs-lisp
  (use-package writeroom-mode
    :bind (("C-c t r" . writeroom-mode)))

  (use-package focus
    :bind (("C-c t f" . focus-mode)))
#+END_SRC

The [[https://github.com/joostkremers/writeroom-mode][=writeroom-mode=]] package hides most of the interface and centres
the text, similar to the writeroom text editor; and the [[https://github.com/larstvei/Focus][=focus=]]
package dims surrounding paragraphs. They make a good combination.

*** LaTeX

Automatically parse TeX files after opening, insert braces
automatically for math mode sub/superscripts, and attempt to "do what
I mean" in figuring out what the main tex file is.

#+BEGIN_SRC emacs-lisp
  (setq TeX-parse-self t
        TeX-electric-sub-and-superscript t
        TeX-master 'dwim)
#+END_SRC

Some help for managing bibtex databases: I like my formatting
consistent.

#+BEGIN_SRC emacs-lisp
  (setq bibtex-entry-format `(opts-or-alts numerical-fields page-dashes
                              last-comma delimiters unify-case sort-fields)
        bibtex-entry-delimiters 'braces
        bibtex-field-delimiters 'double-quotes
        bibtex-comma-after-last-field nil)

  (defvar barrucadu/bibtex-fields-ignore-list
    '("abstract" "acmid" "address" "annotation" "articleno" "eprint"
      "file" "isbn" "issn" "issue_date" "keywords" "language" "location"
      "month" "numpages" "url"))

  (defun barrucadu/bibtex-clean-entry-drop-fields ()
    (save-excursion
      (let (bounds)
        (when (looking-at bibtex-entry-maybe-empty-head)
          (goto-char (match-end 0))
          (while (setq bounds (bibtex-parse-field))
            (goto-char (bibtex-start-of-field bounds))
            (if (member (bibtex-name-in-field bounds)
                        barrucadu/bibtex-fields-ignore-list)
                (kill-region (caar bounds) (nth 3 bounds))
              (goto-char (bibtex-end-of-field bounds))))))))

  (defun barrucadu/bibtex-clean-entry-newline ()
    (save-excursion
      (progn (bibtex-end-of-entry) (left-char) (newline))))

  (add-hook 'bibtex-clean-entry-hook 'barrucadu/bibtex-clean-entry-newline)
  (add-hook 'bibtex-clean-entry-hook 'barrucadu/bibtex-clean-entry-drop-fields)
#+END_SRC

*** Markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode "\\.md\\'\\|\\.markdown\\'")
#+END_SRC

** Version control

Highlight diffs in the buffer:

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :defer t
    :init
    (global-diff-hl-mode)
    (add-hook 'dired-mode-hook 'diff-hl-dired-mode)
    (unless (display-graphic-p) (diff-hl-margin-mode))
    (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
#+END_SRC

The [[https://magit.vc/][=magit=]] package is the best thing since sliced bread:

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind (("C-c g c" . magit-clone)
           ("C-c g s" . magit-status)
           ("C-c g b" . magit-blame)
           ("C-c g l" . magit-log-buffer-line)
           ("C-c g p" . magit-pull))
    :init (setq magit-save-repository-buffers 'dontask
                magit-refs-show-commit-count 'all
                magit-revision-show-gravatars nil
                magit-repository-directories `(("~" . 2))
                magit-repolist-columns
                '(("Name"    25 magit-repolist-column-ident                  ())
                  ("Version" 25 magit-repolist-column-version                ())
                  ("Dirty"    1 magit-repolist-column-dirty                  ())
                  ("Unpulled" 3 magit-repolist-column-unpulled-from-upstream ((:right-align t)))
                  ("Unpushed" 3 magit-repolist-column-unpushed-to-upstream   ((:right-align t)))
                  ("Path"    99 magit-repolist-column-path                   ()))))
#+END_SRC

The [[https://github.com/pidu/git-timemachine][=git-timemachine=]] package is quite handy for stepping through old
versions of things:

#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :bind (("C-c g t" . git-timemachine)))
#+END_SRC

** Miscellaneous
*** Change some silly defaults

Don't make backup files:

#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
#+END_SRC

Kill whole lines:

#+BEGIN_SRC emacs-lisp
  (setq kill-whole-line t)
#+END_SRC

I find "C-x u" much more awkward to type than "C-x C-u":

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x C-u" 'undo)
#+END_SRC

I am incredibly lazy and don't like to type "yes" when "y" will suffice:

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

"Tabs are the devil's whitespace" - Harry Schwartz:

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil
                tab-width 8)
#+END_SRC

End files with a trailing newline:

#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)
#+END_SRC

*** Buffer management and navigation

Use the "forward" style of creating unique buffer names, which
includes part of the directory in the buffer name:

#+BEGIN_SRC emacs-lisp
  (setq uniquify-buffer-name-style 'forward)
#+END_SRC

Add a binding to switch to the previous buffer:

#+BEGIN_SRC emacs-lisp
  (defun barrucadu/switch-to-previous-buffer ()
    (interactive)
    (switch-to-buffer (other-buffer)))
  (bind-key "C-c b x" 'barrucadu/switch-to-previous-buffer)
#+END_SRC

Bind a key to jump to a line:

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x g" 'goto-line)
#+END_SRC

*** Whitespace

Use [[https://github.com/purcell/whitespace-cleanup-mode][=whitespace-cleanup-mode=]] to sort out trailing whitespace, and
make whitespace optionally visible (trailing whitespace is always
visible):

#+BEGIN_SRC emacs-lisp
  ;;;; Whitespace management
  (use-package whitespace-cleanup-mode
    :bind (("C-c t c" . whitespace-cleanup-mode)
           ("C-c x w" . whitespace-cleanup))
    :init (dolist (hook '(prog-mode-hook text-mode-hook conf-mode-hook))
            (add-hook hook 'whitespace-cleanup-mode))
    :diminish (whitespace-cleanup-mode . " [W]"))

  (use-package whitespace
    :bind (("C-c t w" . whitespace-mode))
    :config (setq whitespace-line-column nil)
    :diminish whitespace-mode)

  (bind-key "C-c x d" 'delete-horizontal-space)
  (setq-default show-trailing-whitespace t)
#+END_SRC

*** Visual regexp search and replace

#+BEGIN_SRC emacs-lisp
  (use-package visual-regexp
    :bind (("C-c s r" . vr/query-replace)
           ("C-c s R" . vr/replace)))
#+END_SRC

*** Helm

The [[https://emacs-helm.github.io/helm/][=helm=]] package provides incremental completion of lots of things,
so I enable it globally. For example, this makes =M-x= much nicer.

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :bind ("M-x" . helm-M-x)
    :init (helm-mode 1)
    :diminish helm-mode)
#+END_SRC

Manage buffers with =helm=:

#+BEGIN_SRC emacs-lisp
  (use-package helm-buffers
    :ensure helm
    :defer t
    :bind (([remap switch-to-buffer] . helm-mini))
    :config (setq helm-buffers-fuzzy-matching t))
#+END_SRC

Manage files with =helm=:

#+BEGIN_SRC emacs-lisp
  (use-package helm-files
    :ensure helm
    :defer t
    :bind (([remap find-file] . helm-find-files)
           ("C-c f f" . helm-for-files)
           ("C-c f r" . helm-recentf))
    :config (setq helm-recentf-fuzzy-match t
                  helm-ff-file-name-history-use-recentf t
                  helm-ff-search-library-in-sexp t))
#+END_SRC

*** Projectile

The [[https://github.com/bbatsov/projectile][=projectile=]] package is a project integration library, providing
nice functionality at the level of all files in a git repository
(amongst others).

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :init (projectile-global-mode)
    :config (setq projectile-completion-system 'helm))
#+END_SRC

Use =helm= for autocompletion:

#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :after projectile
    :bind ("C-c f p" . helm-projectile)
    :config
    (helm-projectile-on)
    (setq projectile-switch-project-action 'helm-projectile))
#+END_SRC
